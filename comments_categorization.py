# -*- coding: utf-8 -*-
"""Comments Categorization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I7wNNgkU3Z0uKpWwPAEmNRfuoW1NusaI
"""

# Jupyter Notebook to categorize comments in a CSV file
# Run each cell in order

# Cell 1: Import necessary libraries
import pandas as pd
import re
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display, HTML, clear_output
import io

# Import widgets for file upload
import ipywidgets as widgets
from ipywidgets import Button, HBox, VBox, Label, Output

# Try to import Google Colab files module (will succeed in Colab, fail in regular Jupyter)
try:
    from google.colab import files
    is_colab = True
    print("Google Colab environment detected.")
except ImportError:
    is_colab = False
    print("Regular Jupyter Notebook environment detected.")

# Cell 2: Define categorization function
def categorize_comment(comment):
    """
    Categorize comments based on specific rules:
    1. One or two word comments are Acknowledgement
    2. If contains running techniques (HR, cadence, etc.) = Technical Feedback
    3. If contains words of encouragement = Motivation & Encouragement
    4. If positive comment = Positive Feedback
    5. Else = General
    """
    if not isinstance(comment, str) or not comment.strip():
        return "General"

    # Rule 1: One or two word comments are Acknowledgement
    # Remove HTML tags, emojis, and other non-word characters before counting words
    clean_comment = re.sub(r'<.*?>|&nbsp;|&#\d+;|\W+', ' ', comment)
    words = [word for word in clean_comment.split() if word.strip()]
    if len(words) <= 2:
        return "Acknowledgement"

    # Convert to lowercase for case-insensitive matching
    comment_lower = comment.lower()

    # Rule 2: Technical Feedback - contains running technique terms
    technical_terms = ['hr', 'heart rate', 'cadence', 'pace', 'stride', 'form',
                      'technique', 'split', 'tempo', 'speed', 'distance', 'km',
                      'miles', 'elevation', 'intervals', 'recovery', 'metrics']

    if any(term in comment_lower for term in technical_terms):
        return "Technical Feedback"

    # Rule 3: Motivation & Encouragement
    encouragement_terms = ['great job', 'well done', 'keep it up', 'good work',
                          'awesome', 'amazing', 'proud', 'impressed', 'keep going',
                          'encouraging', 'motivating', 'fantastic', 'excellent',
                          'wonderful', 'superb', 'terrific', 'bravo', 'kudos']

    if any(term in comment_lower for term in encouragement_terms):
        return "Motivation & Encouragement"

    # Rule 4: Positive Feedback
    positive_terms = ['good', 'nice', 'great', 'love', 'enjoy', 'happy', 'impressive',
                     'perfect', 'well', 'congrats', 'congratulations', 'thumbs up']

    if any(term in comment_lower for term in positive_terms):
        return "Positive Feedback"

    # Rule 5: If none of the above, it's General
    return "General"

# Cell 3: File Upload Methods (Choose the appropriate section based on your environment)

# Global variable to store our dataframe
df = None
csv_filename = None

# For Google Colab
if is_colab:
    print("=== Upload a CSV file using Google Colab's file uploader ===")
    print("Click the 'Choose Files' button below and select your CSV file.")

    uploaded = files.upload()

    if uploaded:
        csv_filename = list(uploaded.keys())[0]
        df = pd.read_csv(csv_filename)
        print(f"File '{csv_filename}' uploaded and loaded successfully!")
    else:
        print("No file was uploaded.")

# For regular Jupyter Notebook
else:
    print("=== Upload a CSV file using the widget below ===")

    upload_output = Output()

    # Create file upload widget
    file_upload = widgets.FileUpload(
        accept='.csv',
        multiple=False,
        description='Select CSV file:',
        layout=widgets.Layout(width='300px')
    )

    # Button to process the uploaded file
    process_button = Button(
        description='Process File',
        disabled=True,
        button_style='success',
        tooltip='Click to process the uploaded file',
        icon='check'
    )

    status_label = Label(value="Please upload a CSV file.")

    # Function to handle file upload
    def on_upload_change(change):
        if file_upload.value:
            process_button.disabled = False
            filename = list(file_upload.value.keys())[0]
            status_label.value = f"File '{filename}' selected. Click 'Process File' to continue."
        else:
            process_button.disabled = True
            status_label.value = "Please upload a CSV file."

    # Function to process the uploaded file
    def on_process_button_clicked(b):
        global df, csv_filename

        with upload_output:
            clear_output()
            if not file_upload.value:
                print("No file uploaded!")
                return

            # Get the uploaded file content
            filename = list(file_upload.value.keys())[0]
            content = file_upload.value[filename]['content']

            # Convert content to pandas dataframe
            try:
                csv_filename = filename
                df = pd.read_csv(io.BytesIO(content))
                print(f"File '{filename}' processed successfully!")
                print(f"Found {len(df)} rows and {len(df.columns)} columns.")
            except Exception as e:
                print(f"Error processing file: {str(e)}")
                return

    # Connect event handlers
    file_upload.observe(on_upload_change, names='value')
    process_button.on_click(on_process_button_clicked)

    # Display widgets
    display(VBox([file_upload, status_label, process_button, upload_output]))

    print("Upload a CSV file and click 'Process File' to continue.")

# Cell 4: Check if data is loaded and display the first few rows
def process_data():
    global df

    if df is None or len(df) == 0:
        print("No data available. Please upload a CSV file first.")
        return False

    # Check if required column exists
    if 'comment_text' not in df.columns:
        print("Error: CSV file must contain a 'comment_text' column")
        return False

    # Display first few rows
    print("\nFirst 5 rows of the dataset:")
    display(df.head())
    print(f"Total rows: {len(df)}")

    return True

# Cell 5: Categorize the comments
def categorize_data():
    global df

    if not process_data():
        return

    print("\nCategorizing comments...")
    df['category'] = df['comment_text'].apply(categorize_comment)
    print("Categorization complete!")

    # Display the category distribution
    category_counts = df['category'].value_counts()
    total_comments = len(df)

    print("\nCategory Distribution:")
    for category, count in category_counts.items():
        percentage = (count / total_comments) * 100
        print(f"{category}: {count} ({percentage:.2f}%)")

    # Visualize the distribution
    plt.figure(figsize=(14, 6))
    sns.set(style="whitegrid")

    # Bar plot
    plt.subplot(1, 2, 1)
    ax = sns.barplot(x=category_counts.index, y=category_counts.values)
    plt.title('Comment Categories Distribution')
    plt.xlabel('Category')
    plt.ylabel('Count')
    plt.xticks(rotation=45)

    # Add value labels on top of bars
    for i, v in enumerate(category_counts.values):
        ax.text(i, v + 50, str(v), ha='center')

    # Pie chart
    plt.subplot(1, 2, 2)
    plt.pie(category_counts.values, labels=category_counts.index, autopct='%1.1f%%',
            startangle=90, shadow=True)
    plt.axis('equal')
    plt.title('Percentage of Each Category')

    plt.tight_layout()
    plt.show()

    # Show examples from each category
    for category in category_counts.index:
        print(f"\nExamples of '{category}' comments:")
        examples = df[df['category'] == category]['comment_text'].head(3).tolist()
        for i, example in enumerate(examples, 1):
            if isinstance(example, str):
                # Truncate long examples
                if len(example) > 100:
                    example = example[:100] + "..."
                print(f"{i}. {example}")
            else:
                print(f"{i}. (Non-text value)")

# Cell 6: Save and download the categorized data
def save_data():
    global df, csv_filename

    if df is None or csv_filename is None:
        print("No data to save. Please upload and process a CSV file first.")
        return

    # Generate output filename
    output_file = f"categorized_{csv_filename}"

    # Save the dataframe to CSV
    df.to_csv(output_file, index=False)
    print(f"\nCategorized data saved to: {output_file}")

    # Download the file
    if is_colab:
        print("Downloading the file...")
        files.download(output_file)
    else:
        # For Jupyter Notebook, create a download link
        from IPython.display import HTML

        def create_download_link(df, filename, text="Download CSV file"):
            csv = df.to_csv(index=False)
            b64 = pd.io.common.base64.b64encode(csv.encode())
            payload = b64.decode()
            html = f'<a download="{filename}" href="data:text/csv;base64,{payload}" target="_blank">{text}</a>'
            return HTML(html)

        display(create_download_link(df, output_file))

# Cell 7: Execute the categorization process (run this cell when ready)
# You can also call these functions separately if you prefer
if df is not None:
    categorize_data()
    save_data()
else:
    print("Please upload a CSV file first (run the upload cell above).")